<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://fbraza.github.io/BrazLog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://fbraza.github.io/BrazLog/" rel="alternate" type="text/html" /><updated>2021-07-09T04:20:47-05:00</updated><id>https://fbraza.github.io/BrazLog/feed.xml</id><title type="html">Lost in Datation</title><subtitle>Python 路 Scala 路 BigData 路 System Design 路 Data Engineering</subtitle><entry><title type="html">Guide for optimizing performance with Spark</title><link href="https://fbraza.github.io/BrazLog/spark/python/scala/2021/07/08/spark-optimization.html" rel="alternate" type="text/html" title="Guide for optimizing performance with Spark" /><published>2021-07-08T00:00:00-05:00</published><updated>2021-07-08T00:00:00-05:00</updated><id>https://fbraza.github.io/BrazLog/spark/python/scala/2021/07/08/spark-optimization</id><author><name></name></author><category term="Spark" /><category term="Python" /><category term="Scala" /><summary type="html">Apache Spark is an analytics engine designed to be particularly efficient to process Big Data. You can use Spark on an on-premise or a cloud-deployed Hadoop cluster or through the Databricks platform. In any of these setups, using Spark efficiently is critical if you want to control and reduce costs. For that you should be able to diagnose and resolve some common performance issues. These usually fall into the five following categories: spill, skew, shuffle, storage and serialization. Here we are going to go over each of them to understand what they are, see how to identify them and mitigate their impact on your workflow.</summary></entry><entry><title type="html">Modern Python part 3 - run a CI pipeline &amp;amp; publish your package to PiPy</title><link href="https://fbraza.github.io/BrazLog/python/devops/2021/06/29/modern-python-part3.html" rel="alternate" type="text/html" title="Modern Python part 3 - run a CI pipeline &amp;amp; publish your package to PiPy" /><published>2021-06-29T00:00:00-05:00</published><updated>2021-06-29T00:00:00-05:00</updated><id>https://fbraza.github.io/BrazLog/python/devops/2021/06/29/modern-python-part3</id><author><name></name></author><category term="Python" /><category term="DevOps" /><summary type="html">To propose a well-maintained and usable Python package to the open-source community or even inside your company, you are expected to accomplish a set of critical steps. First ensure that your code is unit tested. Second respect the common writing and format styles. Automate these steps and integrate them in a continuous integration pipeline to avoid any regression that stems from modifications applied to your source code. Finally, provide enough documentation for future users. Once done it is common to publish your Python package on the Python Package Index (PyPI). Here we are going to see how to accomplish each of these steps using Poetry, Tox and GitHub Actions. The code used for our use case can be found on our repository.</summary></entry><entry><title type="html">Modern Python part 2 - write unit tests &amp;amp; enforce Git commit conventions</title><link href="https://fbraza.github.io/BrazLog/python/devops/2021/06/24/modern-python-part2.html" rel="alternate" type="text/html" title="Modern Python part 2 - write unit tests &amp;amp; enforce Git commit conventions" /><published>2021-06-24T00:00:00-05:00</published><updated>2021-06-24T00:00:00-05:00</updated><id>https://fbraza.github.io/BrazLog/python/devops/2021/06/24/modern-python-part2</id><author><name></name></author><category term="Python" /><category term="DevOps" /><summary type="html">Good software engineering practices always bring a lot of long-term benefits. For example, writing unit tests permits you to maintain large codebases and ensures that a specific piece of your code behaves as expected. Writing consistent Git commits also enhance the collaboration between the project stakeholders. Well-crafted Git commit messages open the door to automatic versioning and generated change log files. Consequently, a lot of attempts are currently ongoing and applied to normalize the messages written in our Git commits.</summary></entry><entry><title type="html">Modern Python part 1 - start a project with pyenv &amp;amp; poetry</title><link href="https://fbraza.github.io/BrazLog/python/devops/2021/06/09/modern-python-part1.html" rel="alternate" type="text/html" title="Modern Python part 1 - start a project with pyenv &amp;amp; poetry" /><published>2021-06-09T00:00:00-05:00</published><updated>2021-06-09T00:00:00-05:00</updated><id>https://fbraza.github.io/BrazLog/python/devops/2021/06/09/modern-python-part1</id><author><name></name></author><category term="Python" /><category term="DevOps" /><summary type="html">When learning a programming language, the focus is essentially on understanding the syntax, the code style, and the underlying concepts. With time, you become sufficiently comfortable with the language and you start writing programs solving new exciting problems.</summary></entry></feed>